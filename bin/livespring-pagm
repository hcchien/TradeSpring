#!/usr/bin/perl -w
use strict;
use Finance::GeniusTrader::Conf;

Finance::GeniusTrader::Conf::load();

package main;
use strict;
use AnyEvent;
use YAML::Syck qw(LoadFile);
use Getopt::Long qw(:config pass_through);
use Log::Log4perl;
use TradeSpring;

my $port = 5019;
my $test_broker;
my $logconf;
my $daytrade;

GetOptions ("test"     => \$test_broker,
            "logconf=s"  => \$logconf,
            "daytrade" => \$daytrade,
            "port=i"     => \$port,
        ) or die;

TradeSpring::init_logging($logconf || 'log.conf');
my $logger = Log::Log4perl->get_logger("tradespring");

my $config = LoadFile(shift) or die;

my $code = shift or die 'code required';
my $tf = shift or die 'timeframe required';
my $strategy_name = shift;
$strategy_name->require or die $@;

my $amq = $config->{anymq};
my $bus = $amq->{traits}
    ? AnyMQ->new_with_traits(%$amq) : AnyMQ->new(%$amq);
warn $bus->cv->recv;

my $pagm = $bus->topic({name => 'pagmctrl.'.$config->{node}});
my $myself = $bus->topic("pagmclient-$$");
my $client = $bus->new_listener($myself);

my $quit = AE::cv;

$client->on_error(sub {
                      warn "ERROR: ".join(',',@_);
                  });


use Finance::GeniusTrader::Calculator;
use Finance::GeniusTrader::Prices;
my $timeframe = Finance::GeniusTrader::DateTime::name_to_timeframe($tf);
my $calc;
$|++;

my $cname = shift;

my ($broker, $c) = $test_broker ? (TradeSpring::local_broker, undef)
                                : TradeSpring::jfo_broker($cname, $port,
                                                          daytrade => $daytrade);

my $cv_ready;
if ($c) {
    my $w; $w = AnyEvent->timer( after => 30,
                                 cb => sub {
                                     $logger->fatal("JFO endpoint not repsonding");
                                     undef $w;
                                     $quit->send(-1);
                                 });
    $cv_ready = AE::cv(
        sub {
            undef $w;
            $client->poll(\&handler);
            $pagm->publish({ type => 'pagm.session', code => $code, reply => $myself->name });
        });
}
else {
    $client->poll(\&handler);
    $pagm->publish({ type => 'pagm.session', code => $code, reply => $myself->name });

}

my ($tick_channel, $ag_channel);
my $strategy;

sub handler {
    my $msg = shift;
    no warnings 'uninitialized';

    if ($msg->{type} eq 'pagm.session') {
        $pagm->publish({type => 'pagm.history', code => $code,
                         timeframe => $tf, count => 144,
                         reply => $myself->name});
        $tick_channel = $msg->{tick_channel};
        $ag_channel = $msg->{ag_channel}.$tf;
    }
    elsif ($msg->{type} eq 'history') {
        my $prices = $msg->{prices};
        $logger->info("loaded ".(scalar @{$prices})." items for $code/$tf from pagm: $prices->[0][5] - $prices->[-1][5]");
        my $p = Finance::GeniusTrader::Prices->new;
        $p->{prices} = $prices;
        $p->set_timeframe($timeframe);
        $calc = Finance::GeniusTrader::Calculator->new($p);

        local $_; # XXX: something is modifying $_ and cause anymq topic reaper trouble
        $strategy = TradeSpring::load_strategy($strategy_name, $calc, $broker);

        $client->subscribe($bus->topic($tick_channel));
        $client->subscribe($bus->topic($ag_channel));

        if ($daytrade) {
            # XXX: load existing position?
            my $start = $calc->prices->count-1;
            my $dt = DateTime->now(time_zone => 'Asia/Taipei');

            while (($p->at($start-1)->[$DATE] =~ m/^([\d-]+)/)[0] eq $dt->ymd ) {
                --$start;
            }
            if ($start != $calc->prices->count-1) {
                for my $i ($start..$calc->prices->count-1) {
                    $strategy->i($i);
                    $strategy->run();
                }
            }
        }
    }
    elsif ($msg->{type} eq 'agbar') { # bar
        next unless $calc;
        my $prices = $msg->{data};

        use Term::ANSIScreen qw(:color :screen);
        print clline;
        print (color 'white');
        print $prices->[$DATE].' = ';
        print color $prices->[$CLOSE] > $prices->[$OPEN] ? 'red' : 'green';
        print join('',map { sprintf("%5d", $_) } @{$prices}[0..3]);
        printf (" V: %6d", $prices->[4]);
        print color 'reset';
        print $/;

        $calc->prices->add_prices($prices);
        $strategy->i($calc->prices->count-1);
        $strategy->run();
    }
    elsif ($msg->{price}) { # tick
        return unless $calc;
        print clline;
        print (color 'white');
        print $msg->{time}.' = ';
        my $pp = $calc->prices->at($calc->prices->count-1);
        my $c = $msg->{price}> $pp->[$CLOSE] ? 'red' : 'green';
        print colored [$c], sprintf(" P: %5d V: %6d", $msg->{price}, $msg->{volume} );
        print "\r";

        $broker->on_price($msg->{price}, $msg->{volume}, $msg->{time});
    }
    else {
        $logger->error("unhandled message: ".Dumper($msg)); use Data::Dumper;
    }
    return 1;
}

# XXX: refactor into broker::jfo loader
use Plack::Builder;
sub _mount_accounts {
    my ($class, $accounts) = @_;

    for my $a (keys %$accounts) {
        my $account = $accounts->{$a};

        my $w; $w = AnyEvent->timer
            ( after => 5,
              interval => 60,
              cb => sub {
                  $w;
                  my $endpoint = $account->{endpoint};
                  $endpoint->jsonrpc_call( 'Ping', { cb => $endpoint->notify_uri.'_' },
                                           cb => sub { $account->{endpoint_seen} = AnyEvent->now },
                                           on_fail => sub { $account->{uk} = undef;
                                                            $logger->warn("endpoint not responding: ".$_[0]);
                                                        });
              });

        mount '/notify/'.$a.'_' => sub {
            my $env = shift;
            my $req = Plack::Request->new($env);
            my $v = $req->parameters->mixed;
            if ($v->{notify} eq 'heartbeat') {
                $account->{_ready}->send if $account->{_ready};
                $account->{uk} = $v->{uk};
            }
            else {
                warn "== unknown heartbeat response ".Dumper($v);use Data::Dumper;
            }
            return [200, ['Content-Type' => 'text/plain'], ['ok']];
        };

        mount '/notify/'.$a => TradeSpring::Broker::JFO->psgi_app;
    }
    mount '/' => sub { [200, ['Content-Type' => 'text/plain'], ['ok']] };
};

# XXX: WSJ-like init
if ($c) {
    require WSJ;

    my $app = builder {
        #    mount '/notify' => TradeSpring::Broker::JFO->psgi_app;
        main->_mount_accounts({ $c->account->name => { _ready => $cv_ready, endpoint => $c->account->endpoint  } })
    }->to_app;

    WSJ->wsj_loader($app, __FILE__, $port);
}
exit $quit->recv;
